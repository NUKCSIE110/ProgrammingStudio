---
title: 20171222作業解法
layout: default
---

## 14:
**概念:**
雖然題目定義最高為100x100的大小，但為了讓邊界處理簡單些，我們宣告102x102大小的二維陣列來處理

**解釋如下:**
> 以下為一個二維陣列
> 
> 
> | X | X | X | X | X | X | X |
> | -------- | -------- | -------- | -------- | -------- | -------- | -------- |
> | X | O     | O     | O     | O     | O     | X     |
> | X | O | O | O | O | O | X |
> | X     | O     | O     | O     | O     | O     | X     |
> | X | O | O | O | O | O | X |
> | X     | O     | O     | O     | O     | O     | X     |
> | X | X | X | X | X | X | X |
> 
  
雖然這是個7x7的陣列，但我們只用中間5x5的區域(O部分)，當地雷在角落或邊界的時，只宣告5x5的陣列的話，那麼周圍8格會有部分超出邊界的情況，如果沒有處理好，會有陣列違規存取的情況發生，所以為了將問題簡單化，採用較大陣列的方式處理

周圍地雷數量判斷好之後，會類似下圖這樣:

> | 1 | 1 | 1 | 0 | 0 | 0 | 0 |
> | -------- | -------- | -------- | -------- | -------- | -------- | -------- |
> | 1 | * | 1 | 0 | 0 | 0 | 0 |
> | 1 | 2 | 2 | 1 | 0 | 0 | 0 |
> | 0 | 1 | * | 1 | 0 | 0 | 0 |
> | 0 | 1 | 1 | 1 | 0 | 0 | 0 |
> | 0 | 0 | 0 | 0 | 0 | 0 | 0 |
> | 0 | 0 | 0 | 0 | 0 | 0 | 0 |
> 
  
但我們只取中間5x5的部分
**實際上輸出:**
  
> | * | 1 | 0 | 0 | 0 |
> | -------- | -------- | -------- | -------- | -------- |
> | 2 | 2 | 1 | 0 | 0 |
> | 1 | * | 1 | 0 | 0 |
> | 1 | 1 | 1 | 0 | 0 |
> | 0 | 0 | 0 | 0 | 0 |
> 
  
    
這樣就完成了5x5不用做邊界處理的MineSweeper了~
  
``` c++
#include<stdio.h>

int main() {
    int n, m;
    int count = 1;
    char tmp;
    //輸入地雷區大小n, m
    while (scanf("%d %d", &n, &m)) {
        if (n == 0 && m == 0) break;
        else if(count>1) printf("\n");
        //建立地雷地圖(map)與危險數字地圖(danZone)陣列
        int map[102][102] = { 0 };
        int danZone[102][102] = { 0 };
        for (int i = 1; i <= n; i++) {
            //因為剛剛是輸入%d 換行字元還在buffer裡面 所以先讀掉
            getchar();
            for (int j = 1; j <= m; j++) {
                scanf("%c", &tmp);
                //將地圖存入陣列
                //數字1代表地雷 0代表安全區
                if (tmp == '*') {
                    map[i][j] = 1;
                }
                else
                    map[i][j] = 0;
            }
        }
        for (int i = 1; i <= n; i++) {
            for (int j = 1; j <= m; j++) {
                if (map[i][j] == 1) {
                    //如果判斷到地雷 進來這個if
                    for (int a = -1; a <= 1; a++)
                        for (int b = -1; b <= 1; b++) {
                            //將周圍8格數字全部+1
                            if (map[i + a][j + b] != 1)
                                danZone[i + a][j + b]++;
                        }
                }
            }
        }
        printf("Field #%d:\n", count);
        count++;
        for (int i = 1; i <= n; i++) {
            for (int j = 1; j <= m; j++) {
                if (map[i][j] == 1) printf("*");
                else printf("%d", danZone[i][j]);
            }
            printf("\n");
        }
        

    }
    return 0;
}

```
